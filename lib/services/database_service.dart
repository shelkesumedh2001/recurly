import 'package:hive_flutter/hive_flutter.dart';

import '../models/app_preferences.dart';
import '../models/enums.dart';
import '../models/subscription.dart';
import '../utils/constants.dart';

/// Database service for managing subscriptions with Hive
class DatabaseService {
  factory DatabaseService() => _instance;
  DatabaseService._internal();
  static final DatabaseService _instance = DatabaseService._internal();

  Box<Subscription>? _subscriptionsBox;

  /// Initialize Hive and open boxes
  Future<void> initialize() async {
    try {
      await Hive.initFlutter();

      // Register Hive adapters (generated by build_runner)
      if (!Hive.isAdapterRegistered(0)) {
        Hive.registerAdapter(SubscriptionAdapter());
      }
      if (!Hive.isAdapterRegistered(1)) {
        Hive.registerAdapter(BillingCycleAdapter());
      }
      if (!Hive.isAdapterRegistered(2)) {
        Hive.registerAdapter(SubscriptionCategoryAdapter());
      }
      // Phase 3: Notification preferences adapters
      if (!Hive.isAdapterRegistered(3)) {
        Hive.registerAdapter(AppPreferencesAdapter());
      }
      if (!Hive.isAdapterRegistered(4)) {
        Hive.registerAdapter(TimeOfDayPreferenceAdapter());
      }

      // Open boxes
      _subscriptionsBox = await Hive.openBox<Subscription>(
        AppConstants.subscriptionsBox,
      );
    } catch (e) {
      throw Exception('Failed to initialize database: $e');
    }
  }

  /// Get the subscriptions box
  Box<Subscription> get _box {
    if (_subscriptionsBox == null || !_subscriptionsBox!.isOpen) {
      throw Exception('Database not initialized. Call initialize() first.');
    }
    return _subscriptionsBox!;
  }

  // ==================== CREATE ====================

  /// Add a new subscription
  Future<void> addSubscription(Subscription subscription) async {
    try {
      await _box.put(subscription.id, subscription);
    } catch (e) {
      throw Exception('Failed to add subscription: $e');
    }
  }

  // ==================== READ ====================

  /// Get all active (non-archived, non-deleted) subscriptions
  List<Subscription> getActiveSubscriptions() {
    try {
      return _box.values
          .where((sub) => !sub.isArchived && sub.deletedAt == null)
          .toList();
    } catch (e) {
      throw Exception('Failed to get active subscriptions: $e');
    }
  }

  /// Get all archived subscriptions
  List<Subscription> getArchivedSubscriptions() {
    try {
      return _box.values.where((sub) => sub.isArchived).toList();
    } catch (e) {
      throw Exception('Failed to get archived subscriptions: $e');
    }
  }

  /// Get subscription by ID
  Subscription? getSubscriptionById(String id) {
    try {
      return _box.get(id);
    } catch (e) {
      throw Exception('Failed to get subscription: $e');
    }
  }

  /// Get all subscriptions (active + archived)
  List<Subscription> getAllSubscriptions() {
    try {
      return _box.values.toList();
    } catch (e) {
      throw Exception('Failed to get all subscriptions: $e');
    }
  }

  // ==================== UPDATE ====================

  /// Update an existing subscription
  Future<void> updateSubscription(Subscription subscription) async {
    try {
      await _box.put(subscription.id, subscription);
    } catch (e) {
      throw Exception('Failed to update subscription: $e');
    }
  }

  /// Archive a subscription (soft delete)
  Future<void> archiveSubscription(String id) async {
    try {
      final subscription = _box.get(id);
      if (subscription != null) {
        final updated = subscription.copyWith(isArchived: true);
        await _box.put(id, updated);
      }
    } catch (e) {
      throw Exception('Failed to archive subscription: $e');
    }
  }

  /// Unarchive a subscription
  Future<void> unarchiveSubscription(String id) async {
    try {
      final subscription = _box.get(id);
      if (subscription != null) {
        final updated = subscription.copyWith(isArchived: false);
        await _box.put(id, updated);
      }
    } catch (e) {
      throw Exception('Failed to unarchive subscription: $e');
    }
  }

  // ==================== DELETE ====================

  /// Permanently delete a subscription
  Future<void> deleteSubscription(String id) async {
    try {
      await _box.delete(id);
    } catch (e) {
      throw Exception('Failed to delete subscription: $e');
    }
  }

  /// Delete all subscriptions (use with caution)
  Future<void> deleteAllSubscriptions() async {
    try {
      await _box.clear();
    } catch (e) {
      throw Exception('Failed to delete all subscriptions: $e');
    }
  }

  // ==================== QUERY METHODS ====================

  /// Get subscriptions sorted by next bill date (soonest first)
  List<Subscription> getSubscriptionsSortedByDate() {
    try {
      final subscriptions = getActiveSubscriptions()
        ..sort((a, b) => a.nextBillDate.compareTo(b.nextBillDate));
      return subscriptions;
    } catch (e) {
      throw Exception('Failed to sort subscriptions: $e');
    }
  }

  /// Get subscriptions sorted by price (highest first)
  List<Subscription> getSubscriptionsSortedByPrice() {
    try {
      final subscriptions = getActiveSubscriptions()
        ..sort((a, b) => b.monthlyEquivalent.compareTo(a.monthlyEquivalent));
      return subscriptions;
    } catch (e) {
      throw Exception('Failed to sort subscriptions: $e');
    }
  }

  /// Get subscriptions sorted by name (A-Z)
  List<Subscription> getSubscriptionsSortedByName() {
    try {
      final subscriptions = getActiveSubscriptions()
        ..sort((a, b) => a.name.toLowerCase().compareTo(b.name.toLowerCase()));
      return subscriptions;
    } catch (e) {
      throw Exception('Failed to sort subscriptions: $e');
    }
  }

  /// Get subscriptions by category
  List<Subscription> getSubscriptionsByCategory(SubscriptionCategory category) {
    try {
      return getActiveSubscriptions()
          .where((sub) => sub.category == category)
          .toList();
    } catch (e) {
      throw Exception('Failed to filter by category: $e');
    }
  }

  /// Calculate total monthly spend across all active subscriptions
  double getTotalMonthlySpend() {
    try {
      final subscriptions = getActiveSubscriptions();
      return subscriptions.fold<double>(
        0,
        (sum, sub) => sum + sub.monthlyEquivalent,
      );
    } catch (e) {
      throw Exception('Failed to calculate total spend: $e');
    }
  }

  /// Get count of active subscriptions
  int getActiveSubscriptionCount() {
    try {
      return getActiveSubscriptions().length;
    } catch (e) {
      throw Exception('Failed to count subscriptions: $e');
    }
  }

  /// Check if free limit has been reached
  bool hasReachedFreeLimit() {
    return getActiveSubscriptionCount() >= AppConstants.freeSubscriptionLimit;
  }

  /// Get subscriptions expiring within the next N days
  List<Subscription> getSubscriptionsExpiringSoon(int days) {
    try {
      final subscriptions = getActiveSubscriptions();
      return subscriptions.where((sub) => sub.daysUntilRenewal <= days).toList();
    } catch (e) {
      throw Exception('Failed to get expiring subscriptions: $e');
    }
  }

  // ==================== RECENTLY DELETED ====================

  /// Get subscriptions in recently deleted (deleted within 30 days)
  List<Subscription> getRecentlyDeletedSubscriptions() {
    try {
      final now = DateTime.now();
      final thirtyDaysAgo = now.subtract(const Duration(days: 30));

      return _box.values.where((sub) {
        if (sub.deletedAt == null) return false;
        return sub.deletedAt!.isAfter(thirtyDaysAgo);
      }).toList();
    } catch (e) {
      throw Exception('Failed to get recently deleted subscriptions: $e');
    }
  }

  /// Move subscription to recently deleted
  Future<void> moveToRecentlyDeleted(String id) async {
    try {
      final subscription = _box.get(id);
      if (subscription != null) {
        final updated = subscription.copyWith(deletedAt: DateTime.now());
        await _box.put(id, updated);
      }
    } catch (e) {
      throw Exception('Failed to move subscription to recently deleted: $e');
    }
  }

  /// Restore subscription from recently deleted
  Future<void> restoreFromRecentlyDeleted(String id) async {
    try {
      final subscription = _box.get(id);
      if (subscription != null) {
        final updated = subscription.copyWith(clearDeletedAt: true);
        await _box.put(id, updated);
      }
    } catch (e) {
      throw Exception('Failed to restore subscription: $e');
    }
  }

  /// Get days remaining before permanent deletion
  int getDaysUntilPermanentDeletion(Subscription subscription) {
    if (subscription.deletedAt == null) return 0;

    final now = DateTime.now();
    final deletionDate = subscription.deletedAt!.add(const Duration(days: 30));
    final daysRemaining = deletionDate.difference(now).inDays;

    return daysRemaining > 0 ? daysRemaining : 0;
  }

  /// Auto-cleanup: permanently delete subscriptions older than 30 days
  Future<int> cleanupOldDeletedSubscriptions() async {
    try {
      final now = DateTime.now();
      final thirtyDaysAgo = now.subtract(const Duration(days: 30));
      int deletedCount = 0;

      final toDelete = _box.values.where((sub) {
        if (sub.deletedAt == null) return false;
        return sub.deletedAt!.isBefore(thirtyDaysAgo);
      }).toList();

      for (final sub in toDelete) {
        await _box.delete(sub.id);
        deletedCount++;
      }

      return deletedCount;
    } catch (e) {
      throw Exception('Failed to cleanup old deleted subscriptions: $e');
    }
  }

  // ==================== LISTENERS ====================

  /// Listen to changes in the subscriptions box
  Stream<BoxEvent> watchSubscriptions() {
    return _box.watch();
  }

  /// Close the database
  Future<void> close() async {
    await _box.close();
  }
}
